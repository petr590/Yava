package x590.yava.operation;

import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import x590.util.annotation.Nullable;
import x590.yava.clazz.ClassInfo;
import x590.yava.clazz.IClassInfo;
import x590.yava.context.DecompilationContext;
import x590.yava.field.FieldDescriptor;
import x590.yava.field.FieldInfo;
import x590.yava.main.Yava;
import x590.yava.method.MethodDescriptor;
import x590.yava.method.MethodInfo;
import x590.yava.operation.array.NewArrayOperation;
import x590.yava.operation.arrayload.IALoadOperation;
import x590.yava.operation.invoke.InvokevirtualOperation;
import x590.yava.operation.other.PopOperation;
import x590.yava.type.Type;
import x590.yava.type.primitive.PrimitiveType;
import x590.yava.type.reference.ClassType;

import java.util.List;
import java.util.function.Consumer;

public final class OperationUtils {

	private OperationUtils() {
	}


	public static void removeIfAutogeneratedCheckForNull(DecompilationContext context, Operation object) {
		if (!Yava.getConfig().showAutogenerated()) {
			var prevOperation = context.currentScope().getLastOperation();

			if (prevOperation instanceof PopOperation pop &&
					pop.getOperand() instanceof InvokevirtualOperation invokevirtual &&
					invokevirtual.getDescriptor().equals(ClassType.CLASS, ClassType.OBJECT, "getClass") &&
					invokevirtual.getObject() == object) {

				pop.remove();
			}
		}
	}


	public static void tryInlineVarargs(DecompilationContext context,
										MethodDescriptor descriptor, List<Operation> arguments,
										IClassInfo classinfo, MethodInfo methodInfo) {

		List<Type> argTypes = descriptor.getArguments();

		final int lastIndex = arguments.size() - 1;

		if (lastIndex != argTypes.size() - 1) {
			throw new IllegalArgumentException("Arguments count not matches with descriptor arguments count");
		}

		if (methodInfo.getModifiers().isVarargs()) {
			if (!argTypes.isEmpty() && argTypes.get(lastIndex).isArrayType()) {

				Operation lastOperation = arguments.get(lastIndex);

				if (lastOperation instanceof NewArrayOperation varargsArray && varargsArray.canInitAsList()) {
					var name = descriptor.getName();
					var argumentsCount = lastIndex + varargsArray.getLength();

					if (!classinfo.hasMethodByDescriptor(
							methodDescriptor ->
									!methodDescriptor.equals(descriptor) && methodDescriptor.getName().equals(name) &&
											methodDescriptor.getArguments().size() == argumentsCount)
					) {
						arguments.remove(lastIndex);
						varargsArray.remove();

						List<Operation> initializers = varargsArray.getInitializers();
						initializers.forEach(Operation::denyImplicitCast);

						arguments.addAll(initializers);
					}
				}

			} else {
				context.warning("Varargs method " + descriptor + " must have an array as the last argument");
			}
		}
	}


	public static @Nullable Int2ObjectMap<String> getEnumTable(FieldDescriptor descriptor) {
		return ClassInfo.findIClassInfo(descriptor.getDeclaringClass())
				.flatMap(iclassinfo -> iclassinfo.findFieldInfo(descriptor))
				.map(FieldInfo::getEnumTable).orElse(null);
	}

	public static @Nullable Int2ObjectMap<String> getEnumTable(MethodDescriptor descriptor) {
		return ClassInfo.findIClassInfo(descriptor.getDeclaringClass())
				.flatMap(iclassinfo -> iclassinfo.findMethodInfo(descriptor))
				.map(MethodInfo::getEnumTable).orElse(null);
	}


	public static @Nullable Operation getEnumValueInSwitch(DecompilationContext context,
														   Operation value,
														   Consumer<Int2ObjectMap<String>> enumTableSetter) {

		if (value instanceof IALoadOperation iaload) {

			var enumTable = iaload.getArray().getEnumTable(context);

			if (enumTable != null &&
					iaload.getIndex() instanceof InvokevirtualOperation invokevirtual &&
					isDescriptorOrdinal(invokevirtual.getDescriptor())) {

				enumTableSetter.accept(enumTable);

				return invokevirtual.getObject();
			}
		}

		return null;
	}


	public static boolean isDescriptorOrdinal(MethodDescriptor descriptor) {
		return descriptor.equalsIgnoreClass(PrimitiveType.INT, "ordinal");
	}


	public static @Nullable Int2ObjectMap<String> initEnumTable(
			FieldDescriptor descriptor,
			@Nullable Int2ObjectMap<String> enumTable,
			Consumer<@Nullable Int2ObjectMap<String>> enumTableSetter
	) {

		if (enumTable != FieldInfo.UNDEFINED_ENUM_TABLE)
			return enumTable;

		enumTable = getEnumTable(descriptor);
		enumTableSetter.accept(enumTable);
		return enumTable;
	}


	public static @Nullable Int2ObjectMap<String> initEnumTable(
			MethodDescriptor descriptor,
			@Nullable Int2ObjectMap<String> enumTable,
			Consumer<@Nullable Int2ObjectMap<String>> enumTableSetter
	) {

		if (enumTable != FieldInfo.UNDEFINED_ENUM_TABLE)
			return enumTable;

		enumTable = getEnumTable(descriptor);
		enumTableSetter.accept(enumTable);
		return enumTable;
	}
}
